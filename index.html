<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>知能情報工学 インタラクティブ学習ガイド</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals (Stone, Teal) -->
    <!-- Application Structure Plan: A tab-based SPA with four main interactive views: 1) A clickable conceptual map for exploration. 2) A side-by-side method comparison tool. 3) Keyword flashcards for review. 4) A model selection simulator for practical understanding. This structure transforms a linear document into a multi-faceted study tool, catering to different learning styles (visual, comparative, active recall) and improving usability over a simple text page. -->
    <!-- Visualization & Content Choices: Major concepts are presented on a clickable HTML/CSS map (Goal: Organize). Details appear in modals, sometimes with illustrative Chart.js canvases (e.g., scatter plot for Regression, Goal: Inform). A dynamic HTML table is used for comparisons (Goal: Compare). HTML/CSS cards are used for keywords (Goal: Inform). An interactive quiz uses HTML forms (Goal: Engage). This approach avoids static text walls and promotes interaction. CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
        }
        .tab-active {
            border-color: #0d9488; /* teal-600 */
            color: #0d9488;
            background-color: #f0fdfa; /* teal-50 */
        }
        .concept-node {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .concept-node:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .modal {
            transition: opacity 0.3s ease;
        }
        .flashcard-container {
            perspective: 1000px;
        }
        .flashcard {
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .flashcard.is-flipped {
            transform: rotateY(180deg);
        }
        .flashcard-face {
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        .flashcard-back {
            transform: rotateY(180deg);
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
            height: 250px;
            max-height: 300px;
        }
        @media (min-width: 640px) {
            .chart-container {
                height: 300px;
                max-height: 350px;
            }
        }
    </style>
</head>
<body class="bg-stone-50 text-stone-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-teal-800">知能情報工学 インタラクティブ学習ガイド</h1>
            <p class="text-stone-600 mt-2">主要な概念を対話的に学び、テストに備えましょう。</p>
        </header>

        <div class="mb-8 border-b border-stone-300">
            <nav class="flex flex-wrap -mb-px justify-center" id="tabs">
                <button data-tab="map" class="tab-btn text-lg py-3 px-5 border-b-4 font-medium tab-active">学習マップ</button>
                <button data-tab="comparison" class="tab-btn text-lg py-3 px-5 border-b-4 font-medium border-transparent hover:border-stone-400">手法比較</button>
                <button data-tab="flashcards" class="tab-btn text-lg py-3 px-5 border-b-4 font-medium border-transparent hover:border-stone-400">キーワード</button>
                <button data-tab="simulator" class="tab-btn text-lg py-3 px-5 border-b-4 font-medium border-transparent hover:border-stone-400">モデル選択</button>
            </nav>
        </div>

        <main id="tab-content">
            <!-- 学習マップ -->
            <div id="map" class="tab-pane">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-stone-700">概念のつながり</h2>
                    <p class="text-stone-500 mt-1">知りたい項目をクリックして詳細を確認しましょう。</p>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-8 items-start">
                    <!-- 教師あり学習 -->
                    <div class="space-y-4 p-4 bg-white rounded-xl shadow-md">
                        <h3 class="text-xl font-bold text-center text-teal-700 bg-teal-50 py-2 rounded-lg">教師あり学習</h3>
                        <div class="space-y-3">
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('regression')">回帰モデル</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('svm')">サポートベクターマシン</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('tree')">決定木 / ランダムフォレスト</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('nn')">ニューラルネットワーク</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('deep')">深層学習</div>
                        </div>
                    </div>
                    <!-- 教師なし学習 -->
                    <div class="space-y-4 p-4 bg-white rounded-xl shadow-md">
                        <h3 class="text-xl font-bold text-center text-teal-700 bg-teal-50 py-2 rounded-lg">教師なし学習</h3>
                        <div class="space-y-3">
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('pca')">主成分分析</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('clustering')">クラスタリング</div>
                        </div>
                    </div>
                    <!-- その他 -->
                    <div class="space-y-4 p-4 bg-white rounded-xl shadow-md">
                        <h3 class="text-xl font-bold text-center text-teal-700 bg-teal-50 py-2 rounded-lg">重要キーワード</h3>
                        <div class="space-y-3">
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('preprocessing')">データ前処理</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('validation')">学習/検証データ</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('optimization')">最適化手法</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('evaluation')">評価指標</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('regularization')">過学習と正則化</div>
                            <div class="concept-node bg-stone-100 p-3 rounded-lg text-center" onclick="showModal('ensemble')">アンサンブル学習</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 手法比較 -->
            <div id="comparison" class="tab-pane hidden">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-stone-700">手法比較ツール</h2>
                    <p class="text-stone-500 mt-1">比較したい手法を2つ選択してください。</p>
                </div>
                <div class="flex justify-center gap-4 mb-6">
                    <select id="compare1" class="p-2 border rounded-lg bg-white shadow-sm">
                        <option value="regression">回帰モデル</option>
                        <option value="svm">SVM</option>
                        <option value="tree">決定木/ランダムフォレスト</option>
                        <option value="nn">ニューラルネットワーク</option>
                        <option value="pca">主成分分析</option>
                        <option value="clustering">クラスタリング</option>
                    </select>
                    <select id="compare2" class="p-2 border rounded-lg bg-white shadow-sm">
                        <option value="regression">回帰モデル</option>
                        <option value="svm" selected>SVM</option>
                        <option value="tree">決定木/ランダムフォレスト</option>
                        <option value="nn">ニューラルネットワーク</option>
                        <option value="pca">主成分分析</option>
                        <option value="clustering">クラスタリング</option>
                    </select>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full min-w-max bg-white rounded-xl shadow-md overflow-hidden">
                        <thead class="bg-teal-600 text-white">
                            <tr>
                                <th class="p-3 text-left">項目</th>
                                <th id="header1" class="p-3 text-left"></th>
                                <th id="header2" class="p-3 text-left"></th>
                            </tr>
                        </thead>
                        <tbody id="comparison-table-body" class="divide-y divide-stone-200">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- キーワード -->
            <div id="flashcards" class="tab-pane hidden">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-stone-700">キーワードフラッシュカード</h2>
                    <p class="text-stone-500 mt-1">カードをクリックして定義を確認し、左右のボタンで移動します。</p>
                </div>
                <div class="max-w-2xl mx-auto">
                    <div id="flashcard-container" class="flashcard-container h-64 sm:h-72">
                        <div id="flashcard" class="flashcard relative w-full h-full">
                            <div id="flashcard-front" class="flashcard-face absolute w-full h-full bg-white rounded-xl shadow-lg flex items-center justify-center p-6">
                                <h3 class="text-3xl font-bold text-teal-700 text-center"></h3>
                            </div>
                            <div id="flashcard-back" class="flashcard-face flashcard-back absolute w-full h-full bg-teal-50 rounded-xl shadow-lg flex items-center justify-center p-6">
                                <p class="text-stone-700 text-center"></p>
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-between items-center mt-4">
                        <button id="prev-card" class="py-2 px-4 bg-teal-600 text-white rounded-lg hover:bg-teal-700 transition">← 前へ</button>
                        <span id="card-counter" class="text-stone-600 font-medium"></span>
                        <button id="next-card" class="py-2 px-4 bg-teal-600 text-white rounded-lg hover:bg-teal-700 transition">次へ →</button>
                    </div>
                </div>
            </div>

            <!-- モデル選択 -->
            <div id="simulator" class="tab-pane hidden">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-stone-700">モデル選択シミュレーター</h2>
                    <p class="text-stone-500 mt-1">課題に最も適した手法を選択してください。</p>
                </div>
                <div id="simulator-container" class="max-w-3xl mx-auto p-6 bg-white rounded-xl shadow-md">
                    <div id="question-container">
                        <p class="text-lg font-medium text-stone-800 mb-4" id="scenario-question"></p>
                        <div id="answer-options" class="grid grid-cols-1 sm:grid-cols-2 gap-3"></div>
                    </div>
                    <div id="feedback-container" class="mt-4 p-4 rounded-lg hidden">
                        <h4 id="feedback-title" class="font-bold text-lg"></h4>
                        <p id="feedback-text" class="mt-1"></p>
                        <button id="next-question" class="mt-4 py-2 px-4 bg-teal-600 text-white rounded-lg hover:bg-teal-700 transition">次の問題へ</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- モーダル -->
    <div id="modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-3xl max-h-[90vh] overflow-y-auto">
            <div class="p-6 sm:p-8">
                <div class="flex justify-between items-start">
                    <h3 id="modal-title" class="text-2xl sm:text-3xl font-bold text-teal-800 mb-4"></h3>
                    <button onclick="closeModal()" class="text-3xl text-stone-500 hover:text-stone-800">&times;</button>
                </div>
                <div id="modal-content" class="prose max-w-none text-stone-700"></div>
                <div id="modal-chart" class="mt-6">
                    <div class="chart-container">
                        <canvas id="concept-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
    const data = {
        regression: {
            title: '回帰モデル (線形・非線形)',
            type: '教師あり',
            summary: '説明変数（入力）を用いて連続値の目的変数（出力）を予測する手法。',
            content: `
                <p><strong>考え方:</strong> データに最もフィットする数式モデル y=f(x) を見つけることが目的です。</p>
                <p><strong>線形回帰:</strong> 目的変数を説明変数の一次式で表現するモデル。パラメータは最小二乗法で決定されます。関係性が単純で解釈しやすいため、初期分析に適しています。</p>
                <p><strong>非線形回帰:</strong> 多項式回帰やロジスティック回帰など、変数間の関係が曲線的な（非線形な）場合に使用するモデルの総称。より複雑な関係性を捉えられます。</p>
            `,
            use_case: '株価予測、不動産価格の予測、売上予測など、数値を予測するタスク。'
        },
        svm: {
            title: 'サポートベクターマシン (SVM)',
            type: '教師あり',
            summary: 'マージン最大化により高い汎化性能を目指す、主に分類で用いられる強力な手法。',
            content: `
                <p><strong>考え方:</strong> 異なるクラスを分離する決定境界（超平面）を、境界と最も近いデータ（サポートベクター）との距離（マージン）が最大になるように学習します。</p>
                <p><strong>カーネルトリック:</strong> カーネル関数を用いて、元次元で線形分離できないデータを高次元空間に仮想的に写像し、分離を可能にする技術。計算コストを抑えつつ複雑な分類ができます。</p>
            `,
            use_case: '画像認識、テキスト分類、医療診断など、高次元で複雑なデータの分類。'
        },
        tree: {
            title: '決定木 / ランダムフォレスト',
            type: '教師あり',
            summary: '決定木は解釈しやすいが過学習しやすく、ランダムフォレストはその欠点を克服したアンサンブル手法。',
            content: `
                <p><strong>決定木:</strong> 「IF-THEN」ルールでデータを木構造に分割していくモデル。分割基準にはジニ係数などが用いられます。解釈しやすいが、過学習しやすい欠点があります。</p>
                <p><strong>ランダムフォレスト:</strong> 決定木の過学習を抑制するアンサンブル学習手法。ブートストラップで作成した複数のデータセットと、ランダムに選択した説明変数で多数の決定木を構築し、結果を多数決や平均で統合します。単体より高精度で安定的です。</p>
            `,
            use_case: '決定木: 顧客の離反要因分析、医療診断のルール抽出など、判断プロセスの解釈が必要な場合。ランダムフォレスト: 金融の不正検知、製品の需要予測など、高い予測精度が求められる場合。'
        },
        nn: {
            title: 'ニューラルネットワーク (多層パーセプトロン)',
            type: '教師あり',
            summary: '脳の神経細胞を模倣したモデル。多層化と誤差逆伝搬法により非線形問題を解決。',
            content: `
                <p><strong>考え方:</strong> 脳の神経細胞（ニューロン）を模倣したモデル。入力層、隠れ層、出力層からなり、ユニット間の重みを学習します。</p>
                <p><strong>多層パーセプトロン (MLP):</strong> 隠れ層を複数持つことで、単層のパーセプトロンでは解けなかった非線形問題を解決。学習は、出力と正解の誤差を逆方向に伝播させ重みを更新する誤差逆伝搬法で行います。</p>
            `,
            use_case: '画像・音声認識、自然言語処理など、様々なパターン認識タスクの基礎。'
        },
        deep: {
            title: '深層学習 (CNN、生成モデル)',
            type: '教師あり/なし',
            summary: 'ニューラルネットワークの隠れ層をさらに多層にした技術の総称。より複雑な特徴を学習可能。',
            content: `
                <p><strong>畳み込みニューラルネットワーク (CNN):</strong> 主に画像認識用。畳み込み層で局所的特徴を、プーリング層で位置ずれに強い特徴を抽出し、階層的に学習します。</p>
                <p><strong>生成モデル:</strong> データの分布を学習し、新しいデータを生成するモデル。</p>
                <ul>
                    <li><strong>オートエンコーダ:</strong> 入力データをエンコーダで圧縮し、デコーダで復元する。</li>
                    <li><strong>敵対的生成ネットワーク (GAN):</strong> 偽データを生成する生成器と、それを見破る識別器が競い合い、精巧なデータを生成する。</li>
                </ul>
            `,
            use_case: 'CNN: 画像分類、物体検出。オートエンコーダ: 次元削減、異常検知、ノイズ除去。GAN: 画像生成、データ拡張。'
        },
        pca: {
            title: '主成分分析 (PCA)',
            type: '教師なし',
            summary: '多次元データを、情報を極力維持しつつ低次元に要約する（次元削減）手法。',
            content: `
                <p><strong>考え方:</strong> データの分散が最大になる方向を第1主成分、次に大きい方向を第2主成分…として新しい軸を求めます。これにより、元の変数の相関関係を考慮しつつ、より少ない合成変数でデータの特徴を表現できます。数学的にはデータの分散共分散行列の固有ベクトルを求めることに相当します。</p>
            `,
            use_case: '多すぎる変数の削減によるモデルの単純化・高速化、データの可視化。'
        },
        clustering: {
            title: 'クラスタリング',
            type: '教師なし',
            summary: '正解ラベルなしに、似たデータをグループ分けする手法。',
            content: `
                <p><strong>手法:</strong></p>
                <ul>
                    <li><strong>階層的:</strong> 最も似たデータから順にまとめ、過程をデンドログラム（樹形図）で示す。</li>
                    <li><strong>非階層的 (K-means):</strong> クラスタ数kを決め、各データが最も近いクラスタ中心に所属するように分割を繰り返す。</li>
                </ul>
            `,
            use_case: '顧客セグメンテーション（購買行動が似た顧客グループの発見）、異常検知（どのグループにも属さないデータを見つける）、画像領域分割。'
        },
        preprocessing: {
            title: 'データ前処理',
            content: `モデル性能を左右する重要プロセス。アノテーション（タグ付け）、スケーリング（尺度統一）、データクレンジング（欠損値・外れ値等の修正）を含む。`
        },
        validation: {
            title: '学習用/検証用データ',
            content: `過学習を防ぐため、データをモデル構築用の学習用と性能評価用の検証用に分割する。ホールドアウト法や交差検証法がある。`
        },
        optimization: {
            title: '最適化手法',
            content: `<strong>最小二乗法:</strong> 予測と実測値の誤差（残差）の二乗和が最小になるようパラメータを決める手法。<br><strong>勾配降下法:</strong> 誤差関数の勾配を頼りにパラメータを反復更新し、最小値を探す最適化手法。`
        },
        evaluation: {
            title: '評価指標（分類）',
            content: `<strong>混同行列:</strong> 分類モデルの性能評価指標。正解率（全体の正解割合）、適合率（Positive予測の正解割合）、再現率（実際のPositiveをどれだけ検出できたかの割合）、両者のバランスを取ったF1-Scoreがある。`
        },
        regularization: {
            title: '過学習と正則化',
            content: `<strong>過学習 (Over-Fitting):</strong> モデルが学習データを過剰に学習しすぎてしまい、未知の新しいデータに対しては精度が低くなってしまう現象。<br><strong>正則化 (Regularization):</strong> この過学習を防ぐため、評価関数にパラメータの大きさを抑えるペナルティ項を加える手法。モデルが複雑になりすぎるのを防ぐ。L1正則化（Lasso）とL2正則化（Ridge）がある。`
        },
        ensemble: {
            title: 'アンサンブル学習',
            content: `<strong>バギング:</strong> 独立した学習器を並列に作り結果を統合する（例：ランダムフォレスト）。<br><strong>ブースティング:</strong> 学習器を直列に作り、前の間違いを次に活かして精度を高める。`
        }
    };

    const flashcardData = [
        { term: 'AI・機械学習・データサイエンス', definition: 'AI（人間の知的活動の実現）という大きな枠組みの中に、データからパターンを学ぶ機械学習があり、それらの技術を用いてデータから価値を引き出すのがデータサイエンス。' },
        { term: '教師あり/なし学習', definition: '教師ありは正解ラベル付きデータ（説明変数と目的変数）で学習し予測する。教師なしはラベルなしデータから構造やパターンを発見する。' },
        { term: 'データ前処理', definition: 'モデル性能を左右する重要プロセス。アノテーション（タグ付け）、スケーリング（尺度統一）、データクレンジング（欠損値・外れ値等の修正）を含む。' },
        { term: '学習用/検証用データ', definition: '過学習を防ぐため、データをモデル構築用の学習用と性能評価用の検証用に分割する。ホールドアウト法や交差検証法がある。' },
        { term: '最小二乗法/勾配降下法', definition: '最小二乗法は予測と実測値の誤差（残差）の二乗和が最小になるようパラメータを決める手法。勾配降下法は、誤差関数の勾配を頼りにパラメータを反復更新し、最小値を探す最適化手法。' },
        { term: '混同行列', definition: '分類モデルの性能評価指標。正解率、適合率、再現率、両者のバランスを取ったF1-Scoreがある。' },
        { term: '過学習と正則化', definition: '過学習は訓練データに適合しすぎ未知データに弱い状態。正則化は過学習を防ぐためモデルの複雑さにペナルティを課す手法。' },
        { term: 'カーネル', definition: 'SVMで、低次元での計算のまま高次元空間での分離を可能にする関数（カーネルトリック）。多項式カーネルやガウスカーネルが代表的。' },
        { term: 'バギング/ブースティング', definition: 'アンサンブル学習の手法。バギングは独立した学習器を並列に作り結果を統合する（例：ランダムフォレスト）。ブースティングは学習器を直列に作り、前の間違いを次に活かして精度を高める。' },
        { term: '強化学習', definition: '「エージェント」が「環境」内で試行錯誤し、「報酬」を最大化するよう学習する枠組み。' },
        { term: '次元の呪い', definition: '次元の増加に伴い、データが疎になりモデル性能が低下する問題。次元削減が有効。' },
        { term: '誤差逆伝搬法', definition: 'ニューラルネットワークの学習アルゴリズム。出力層の誤差を逆方向に伝え、各層の重みを効率的に更新する。' }
    ];
    
    const simulatorQuestions = [
        {
            question: 'あるECサイトの全顧客を、購買傾向が似ているいくつかのグループに分け、それぞれに合ったキャンペーンを企画したい。',
            options: ['回帰モデル', 'クラスタリング', 'SVM'],
            answer: 'クラスタリング',
            feedback: '正解です。クラスタリングは、正解ラベルなしにデータを似たもの同士でグループ分けする教師なし学習手法であり、顧客セグメンテーションに最適です。'
        },
        {
            question: '過去の気象データ（気温、湿度、風速など）から、明日の具体的な降水量を予測したい。',
            options: ['回帰モデル', '主成分分析', '決定木'],
            answer: '回帰モデル',
            feedback: '正解です。降水量という連続的な数値を予測する問題なので、回帰モデルが適しています。'
        },
        {
            question: '手書きの郵便番号の画像を読み取り、それが0から9のどの数字であるかを自動で判定したい。',
            options: ['SVM', 'クラスタリング', '主成分分析'],
            answer: 'SVM',
            feedback: '正解です。SVMは画像認識のような高次元データの分類問題で高い性能を発揮します。（CNNも良い選択肢です）'
        },
        {
            question: 'ある会社の株価に影響を与えそうな経済指標が100種類ある。これらをより少数の主要な指標にまとめて、市場の全体的な動向を把握したい。',
            options: ['ランダムフォレスト', '主成分分析', 'GAN'],
            answer: '主成分分析',
            feedback: '正解です。主成分分析は、多数の変数を情報を極力維持しつつ少数の合成変数に要約する次元削減手法で、このような場合に適しています。'
        }
    ];

    let currentChart = null;

    function showModal(key) {
        const item = data[key];
        if (!item) return;

        document.getElementById('modal-title').innerText = item.title || '';
        document.getElementById('modal-content').innerHTML = item.content || '';
        document.getElementById('modal').classList.remove('hidden');
        
        const chartContainer = document.getElementById('modal-chart');
        const canvas = document.getElementById('concept-chart');
        
        if (currentChart) {
            currentChart.destroy();
        }

        let chartData;
        switch(key) {
            case 'regression':
                chartData = getChartData.regression();
                break;
            case 'svm':
                chartData = getChartData.svm();
                break;
            case 'tree':
                chartData = getChartData.tree();
                break;
            case 'pca':
                 chartData = getChartData.pca();
                break;
            case 'clustering':
                 chartData = getChartData.clustering();
                break;
            default:
                chartData = null;
        }

        if (chartData) {
            chartContainer.style.display = 'block';
            const ctx = canvas.getContext('2d');
            currentChart = new Chart(ctx, chartData);
        } else {
            chartContainer.style.display = 'none';
        }
    }

    function closeModal() {
        document.getElementById('modal').classList.add('hidden');
        if (currentChart) {
            currentChart.destroy();
            currentChart = null;
        }
    }

    const getChartData = {
        regression: () => ({
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'データ点',
                    data: Array.from({length: 20}, () => ({x: Math.random() * 10, y: Math.random() * 8 + 0.5 * (Math.random() * 10)})),
                    backgroundColor: 'rgba(13, 148, 136, 0.6)'
                }, {
                    label: '回帰直線',
                    data: [{x: 0, y: 1}, {x: 10, y: 6}],
                    type: 'line',
                    borderColor: 'rgb(209, 38, 38)',
                    fill: false,
                    tension: 0.1
                }]
            },
            options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: '回帰分析のイメージ' }}}
        }),
        svm: () => ({
            type: 'scatter',
            data: {
                datasets: [
                    { label: 'クラスA', data: Array.from({length: 15}, () => ({x: Math.random() * 4 + 1, y: Math.random() * 4 + 5})), backgroundColor: 'rgba(13, 148, 136, 0.6)' },
                    { label: 'クラスB', data: Array.from({length: 15}, () => ({x: Math.random() * 4 + 5, y: Math.random() * 4 + 1})), backgroundColor: 'rgba(217, 119, 6, 0.6)' },
                    { label: '決定境界', data: [{x: 0, y: 10}, {x: 10, y: 0}], type: 'line', borderColor: 'rgb(209, 38, 38)', fill: false, tension: 0.1, borderWidth: 2 },
                    { label: 'マージン', data: [{x: 0, y: 11.5}, {x: 11.5, y: 0}], type: 'line', borderColor: 'rgb(209, 38, 38)', fill: false, tension: 0.1, borderDash: [5, 5], borderWidth: 1 },
                    { label: 'マージン', data: [{x: 0, y: 8.5}, {x: 8.5, y: 0}], type: 'line', borderColor: 'rgb(209, 38, 38)', fill: false, tension: 0.1, borderDash: [5, 5], borderWidth: 1 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'SVMのマージン最大化' }}}
        }),
        tree: () => ({
            type: 'scatter',
            data: {
                datasets: [
                    { label: 'クラスA', data: Array.from({length: 15}, () => ({x: Math.random() * 4, y: Math.random() * 10})), backgroundColor: 'rgba(13, 148, 136, 0.6)' },
                    { label: 'クラスB', data: Array.from({length: 15}, () => ({x: Math.random() * 6 + 4, y: Math.random() * 5})), backgroundColor: 'rgba(217, 119, 6, 0.6)' },
                    { label: 'クラスC', data: Array.from({length: 15}, () => ({x: Math.random() * 6 + 4, y: Math.random() * 5 + 5})), backgroundColor: 'rgba(59, 130, 246, 0.6)' }
                ]
            },
            options: { 
                responsive: true, maintainAspectRatio: false, 
                plugins: { 
                    title: { display: true, text: '決定木による領域分割' },
                    annotation: {
                        annotations: {
                            line1: { type: 'line', xMin: 4, xMax: 4, borderColor: 'rgb(209, 38, 38)', borderWidth: 2 },
                            line2: { type: 'line', yMin: 5, yMax: 5, xMin: 4, xMax: 10, borderColor: 'rgb(209, 38, 38)', borderWidth: 2 }
                        }
                    }
                },
                scales: { x: { min: 0, max: 10 }, y: { min: 0, max: 10 } }
            }
        }),
        pca: () => ({
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'データ点',
                    data: Array.from({length: 30}, () => { const a = Math.random() * 10; const b = a + (Math.random()-0.5)*2; return {x: a, y: b}; }),
                    backgroundColor: 'rgba(13, 148, 136, 0.6)'
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { title: { display: true, text: '主成分分析のイメージ' }},
                scales: {
                    x: { title: { display: true, text: '第1主成分 (分散が最大)' } },
                    y: { title: { display: true, text: '第2主成分' } }
                }
            }
        }),
        clustering: () => ({
            type: 'scatter',
            data: {
                datasets: [
                    { label: 'クラスタ1', data: Array.from({length: 15}, () => ({x: Math.random() * 3 + 1, y: Math.random() * 3 + 1})), backgroundColor: 'rgba(13, 148, 136, 0.6)' },
                    { label: 'クラスタ2', data: Array.from({length: 15}, () => ({x: Math.random() * 3 + 6, y: Math.random() * 3 + 2})), backgroundColor: 'rgba(217, 119, 6, 0.6)' },
                    { label: 'クラスタ3', data: Array.from({length: 15}, () => ({x: Math.random() * 3 + 4, y: Math.random() * 3 + 7})), backgroundColor: 'rgba(59, 130, 246, 0.6)' }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'クラスタリングのイメージ' }}}
        })
    };
    
    document.addEventListener('DOMContentLoaded', () => {
        const tabs = document.getElementById('tabs');
        const tabPanes = document.getElementById('tab-content').children;

        tabs.addEventListener('click', (e) => {
            if (e.target.classList.contains('tab-btn')) {
                const tabName = e.target.dataset.tab;

                for (let btn of tabs.children) {
                    btn.classList.remove('tab-active');
                }
                e.target.classList.add('tab-active');

                for (let pane of tabPanes) {
                    if (pane.id === tabName) {
                        pane.classList.remove('hidden');
                    } else {
                        pane.classList.add('hidden');
                    }
                }
            }
        });

        const compare1 = document.getElementById('compare1');
        const compare2 = document.getElementById('compare2');
        
        function updateComparison() {
            const key1 = compare1.value;
            const key2 = compare2.value;
            const item1 = data[key1];
            const item2 = data[key2];

            document.getElementById('header1').innerText = item1.title;
            document.getElementById('header2').innerText = item2.title;

            const tableBody = document.getElementById('comparison-table-body');
            tableBody.innerHTML = `
                <tr class="hover:bg-stone-50">
                    <td class="p-3 font-medium text-stone-600">概要</td>
                    <td class="p-3">${item1.summary}</td>
                    <td class="p-3">${item2.summary}</td>
                </tr>
                <tr class="hover:bg-stone-50">
                    <td class="p-3 font-medium text-stone-600">学習タイプ</td>
                    <td class="p-3">${item1.type}</td>
                    <td class="p-3">${item2.type}</td>
                </tr>
                <tr class="hover:bg-stone-50">
                    <td class="p-3 font-medium text-stone-600">主な利用ケース</td>
                    <td class="p-3">${item1.use_case}</td>
                    <td class="p-3">${item2.use_case}</td>
                </tr>
            `;
        }

        compare1.addEventListener('change', updateComparison);
        compare2.addEventListener('change', updateComparison);
        updateComparison();

        let currentCardIndex = 0;
        const flashcard = document.getElementById('flashcard');
        const frontText = document.querySelector('#flashcard-front h3');
        const backText = document.querySelector('#flashcard-back p');
        const cardCounter = document.getElementById('card-counter');

        function updateFlashcard() {
            flashcard.classList.remove('is-flipped');
            setTimeout(() => {
                const card = flashcardData[currentCardIndex];
                frontText.innerText = card.term;
                backText.innerText = card.definition;
                cardCounter.innerText = `${currentCardIndex + 1} / ${flashcardData.length}`;
            }, 150);
        }

        flashcard.addEventListener('click', () => flashcard.classList.toggle('is-flipped'));
        document.getElementById('prev-card').addEventListener('click', () => {
            currentCardIndex = (currentCardIndex - 1 + flashcardData.length) % flashcardData.length;
            updateFlashcard();
        });
        document.getElementById('next-card').addEventListener('click', () => {
            currentCardIndex = (currentCardIndex + 1) % flashcardData.length;
            updateFlashcard();
        });
        updateFlashcard();

        let currentQuestionIndex = 0;
        const questionEl = document.getElementById('scenario-question');
        const optionsEl = document.getElementById('answer-options');
        const feedbackContainer = document.getElementById('feedback-container');
        const feedbackTitle = document.getElementById('feedback-title');
        const feedbackText = document.getElementById('feedback-text');

        function loadQuestion() {
            feedbackContainer.classList.add('hidden');
            const q = simulatorQuestions[currentQuestionIndex];
            questionEl.innerText = q.question;
            optionsEl.innerHTML = '';
            q.options.forEach(option => {
                const button = document.createElement('button');
                button.innerText = option;
                button.className = 'w-full p-3 bg-stone-100 rounded-lg hover:bg-teal-100 transition text-left';
                button.onclick = () => checkAnswer(option);
                optionsEl.appendChild(button);
            });
        }
        
        function checkAnswer(selectedOption) {
            const q = simulatorQuestions[currentQuestionIndex];
            if (selectedOption === q.answer) {
                feedbackTitle.innerText = '正解！';
                feedbackTitle.className = 'font-bold text-lg text-teal-700';
                feedbackContainer.className = 'mt-4 p-4 rounded-lg bg-teal-50';
            } else {
                feedbackTitle.innerText = '不正解';
                feedbackTitle.className = 'font-bold text-lg text-red-700';
                feedbackContainer.className = 'mt-4 p-4 rounded-lg bg-red-50';
            }
            feedbackText.innerText = q.feedback;
            feedbackContainer.classList.remove('hidden');
        }

        document.getElementById('next-question').addEventListener('click', () => {
            currentQuestionIndex = (currentQuestionIndex + 1) % simulatorQuestions.length;
            loadQuestion();
        });
        
        loadQuestion();
    });
</script>
</body>
</html>
